# GROUPING AND TRANSFORMING SHAPES
----------------------------------

* Introduction
--------------
<1 min
Previously, we learned how to directly edit the shape’s style and position. However, there are instances when you may want to change the appearance of a shape without altering its 
original form. With grouping and transformation functions you can translate, rotate, scale, and shear shapes without changing the code of the shape functions. It is possible to do this 
because the transformation functions modify the coordinate system of the p5.js sketch, not the shape itself. Understanding these grouping and transformation concepts will show you new 
ways to create dynamic p5.js sketches!

By the end of this lesson, you will be able to:

	. Change the origin point from which the shape is drawn from.

	. Change the location of where the shape is drawn without editing its code.

	. Rotate a shape by rotating the p5.js coordinate system.

	. Rotate a shape around its center point.

	. Transform a shape’s size without editing its code.

	. Shear a shape.

	. Isolate styles and transformations using push() and pop().

	. Combine multiple transformation functions to create intricate animations.

* Instructions
--------------
Take a look at the p5.js sketch on your right. Pay attention to the transformation and grouping functions we will cover in this lesson such as rectMode(), translate(), rotate(), 
radians().

Feel free to play around with the code! For example, try changing x -= 5, the for loop expression, to x-= 100. See how that alters the rotation rate and the number of squares in the 
animation.

Whenever you are ready to learn more, click Next to continue!

sketch.js
---------
function setup() {
  createCanvas(windowWidth, windowHeight);
  // Sets origin mode to be the rectangle's center
  rectMode(CENTER);
}

function draw() {
  background(0);

  // Moves rectangle to center of canvas
  translate(width / 2, height / 2);

  // Creates multiple rotating rectangles
  for (let x = 500; x > 0; x -= 5) {
      // Makes height the same as width so it's a square
      let y = x;
      strokeWeight(0.5);
      rotate(radians(frameCount / 50));
      fill(255, x, 255);
      rect(0, 0, x, y);
  }
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Origin
--------
6 min
The origin of the shape determines which point the shape is transformed from. For example, some built-in p5.js drawing functions, such as rect(), are oriented around the upper left corner 
of the shape—but you can always change your shape’s origin point.

The rectMode() and ellipseMode() functions allow you to modify the location from which the shape is drawn by changing how the x and y arguments passed to rect() and ellipse() functions 
are interpreted.

When the rectMode(CENTER) function is called, the x and y coordinates passed to the rect() function changes to represent the center of the rectangle, instead of the top left corner.

The code below shows how to specify a rectangle’s origin point to be its center:

rectMode(CENTER);
rect(200, 200, 250, 250); 

Here, the first argument of the rect() function represents the x position of the origin point, which is now the horizontal center of the rectangle. The second argument, which represents 
the y position of the origin point, is now the vertical center of the rectangle. Since p5.js reads the code from top to bottom, the origin of a shape should be determined before the shape 
is drawn.

The diagram below shows that the rectangle’s origin point is now in the center of the rectangle.

Example of rectMode(CENTER)

With rectMode(CORNER), the x and y coordinates passed into the rect() function represents the rectangle’s top-left corner. If you don’t explicitly call rectMode(CORNER), p5.js will 
automatically assign the origin to be the CORNER.

rectMode(CORNER);
rect(20,20,250,250);    

The above code will produce the same results as the code below, which draws the rectangle without specifying the rectMode(CORNER). Both examples result in the rectangle having a top left 
corner orientation.

rect(20,20,250,250);    

Example of rectMode(CORNER)

In p5.js, ellipses are automatically drawn from the shape’s center. The first and second values that are passed to the ellipse() function represent the x and y coordinates of its center 
point.

The code below explicitly calls ellipseMode(CENTER) which keeps the ellipse’s origin point at the shape’s center.

ellipseMode(CENTER); 
ellipse(200,200,250,250); 

Above code will produce the same results as the one below, which draws the ellipse without specifying ellipseMode(CENTER).

ellipse(200,200,250,250); 

Example of ellipseMode(CENTER)

You can also change the ellipse’s origin to be from its center to its top-left corner by giving CORNER as the argument of the ellipseMode() function. When you use ellipseMode(CORNER), the 
arguments for the x and y positions given to the ellipse() function will represent the top-left corner of the bounding box of the ellipse.

ellipseMode(CORNER);
ellipse(25,25,250,250); 

Example of ellipseMode(CORNER)

* Instructions
--------------
Checkpoint 1 Passed
1.
In the line above the ellipse() function, specify the origin point of the ellipse to be from the CORNER.

Notice how the position of the ellipse changes.


Hint
You can use the ellipseMode() function to specify an ellipse’s origin point.

Checkpoint 2 Passed
2.
In the line above the rect() function, specify the origin point of the rectangle to be from the CENTER.

Notice how the position of the rectangle changes.


Hint
You can use the rectMode() function to specify a rectangle’s origin point.

sketch.js
---------
function setup() {
  createCanvas(windowWidth, windowHeight);
}

function draw() {
  background(0);

  for (let i = 0; i < width; i += 75) {
    for (let j = 0; j < height; j += 75) {
      // Create red ellipse pattern
      fill(255, 0, 0, 180);
      // TODO: Specify a corner origin for the ellipse
      ellipseMode(CORNER);
      ellipse(i, j, 50, 50);

      // Create blue square pattern
      fill(0, 0, 255, 180);
      // TODO: Specify a center origin for the rectangle
      rectMode(CENTER);
      rect(i, j, 50, 50);
    }
  }
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Translate
-----------
6 min
There are two ways to move a shape across your canvas. Let’s say you wanted to move your rectangle 60 pixels right and down, you can add 60 pixels to the x and y coordinates given to the 
rect() function. For example, rect(0, 0, 100, 100) would change to rect(60, 60, 100, 100). This is how we’ve been drawing and positioning shapes so far.

Another method is to move the p5.js coordinate system itself instead of moving the shape. The translate() function does exactly this—it changes the (0, 0) origin of the p5.js coordinate 
system to be the location specified as the function’s arguments.

For example, translate(60, 60) will move the coordinate system 60 pixels to the right and 60 pixels to the bottom. The first argument in the parentheses represents the amount of pixels to 
move along the x-axis. The second argument represents the amount of pixels to move along the y-axis.

Both ways would change the position of your shape, but the main difference is that instead of moving the shape itself, the translate() function moves the entire sketch’s coordinate system 
to the new position specified within the parentheses.

The diagram below shows the rendering of rect(0, 0, 140, 140). As you can see, the shape’s origin point is at (0, 0).

Example of Shape with translate(0, 0)

Notice what happens to the rectangle when you apply translate(40, 40) to it. The rectangle moves 40 pixels right and down without having to change the x and y arguments for the rect() 
function—the first and second arguments of the rect() function remain at (0, 0).

translate(40,40);
rect(0,0,140,140);

Example of Shape with translate(40,40)

Keep in mind that transformation functions, like translate(), accumulate. This means that the x and y values given to a second translate() function will not represent the exact position 
of the new origin. Instead, the values inside the first and second translate() functions will add up to become the new position.

In the diagram below, you can see that while the second rectangle is translated by 160 pixels to the right and the bottom, the top-left corner of the shape is not at the x and y 
coordinate of (160, 160). This is because the second translation by 160 pixels to the right and the bottom is added onto the first translation by 40 pixels to the right and the bottom. 
Together, this adds up to set the new origin at the coordinates (200, 200).

//First rectangle is at (40, 40)
translate(40,40);
rect(0, 0, 80, 80);

//Second rectangle is at (200, 200) because translate() accumulates
translate(160,160);
rect(0, 0, 80, 80);

Example of multiple translations

The main benefit of the translate() function is that the shapes become independent of the position. This means that you can reuse the code for a shape multiple times to be drawn in 
various locations without having to assign new x and y variables for the shape functions.

* Instructions
--------------
Checkpoint 1 Passed
1.
Above the first rect() function that has a width and height of 360 pixels, translate the shape by 60 pixels right and 60 pixels down.


Hint
You can translate a shape using the translate() function with the following syntax:

translate(x, y);

where x represents the number of pixels to move along the x-axis and y represents the number of pixels to move along the y-axis.

Checkpoint 2 Passed
2.
Right above the second rect() function that has a width and height of 180 pixels, translate the shape to be 60 pixels right and 60 pixels down.

Notice how the second rectangle is not in the same location as the first rectangle, even though both rect() functions have the same x and y positions.


Hint
You can translate a shape using the translate() function with the following syntax:

translate(x, y);

Remember that the values for the translate() function accumulate.

sketch.js
---------
function setup() {
  createCanvas(windowWidth, windowHeight);
}

function draw() {
  background(0);

  fill(255,0,0);
  // TODO: Translate the rectangle to be 60px right and down
  translate(60, 60);
  rect(0, 0, 360, 360); 
    
  fill(0,0,255);
  // TODO: Translate the rectangle to be 60px right and down
  translate(60, 60);
  rect(0, 0, 180, 180); 
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Rotate
--------
9 min
Rotating an element in p5.js means rotating the canvas from its top-left corner at (0, 0). Therefore, all the elements drawn on the coordinate system rotates together with the canvas.

The diagram below shows that the coordinate system is being rotated, along with the rectangle drawn on the canvas. The red rectangle shows the original location, while the gray rectangle 
shows its positions when rotated. Notice how the gray square goes off the canvas. This happens because the shape is situated on the rotating p5.js coordinate system.

Example of how rotation works in p5.js

You can rotate the canvas using the rotate() function:

rotate(angle);

The rotate() function takes one argument—the angle of rotation represented by the angle variable in the above code. By default, the angle of rotation is interpreted as a radian value—a 
unit of measuring angles. A single rotation, or a full circle, has 360° in degrees or 2π (6.28) in radians. A half rotation has a 180° in degrees or π (3.14) in radians.

Rotation in Radians and Degrees

p5.js provides representations of pi (π) values, which you can use by spelling out the words like below:

	. π = PI

	. π / 2 = HALF_PI
	
	. π / 4 = QUARTER_PI

	. 2 π = TWO_PI

The code below shows how you would pass in the PI, HALF_PI, QUARTER_PI or TWO_PI value to the rotate() function:

rotate(HALF_PI);

You can also convert a degree value into a radian value by calling the radians() function. For example, radians(180) would equate to 3.14, the equivalent to one π. It is possible to use 
the radians() function inside the rotate() function.

rotate(radians(180));

Alternatively, you can specify the unit of measurement of angles by calling the angleMode() function. Similar to how you set the rectMode() and ellipseMode() to change the shape’s origin, 
the angleMode() determines if the value inside the rotate() function is interpreted as either degrees or radians.

You can set the mode to DEGREES by writing:

angleMode(DEGREES);

You can also specify the mode to be RADIANS, but keep in mind that the default mode for angles and the rotate() function is already RADIANS.

angleMode(RADIANS);

* Instructions
--------------
Checkpoint 1 Passed
1.
Below the fill() function, rotate the canvas by a quarter pi (π).


Hint
To rotate a shape, use the rotate() function like below:

rotate(angleAmount);

where angleAmount is the amount of angle to rotate the canvas by.

Remember, you need to spell out the word for π as PI.

Checkpoint 2 Passed
2.
Below the rotate() function you just wrote, specify the angle mode to be DEGREES.

Notice how changing the angle mode to degrees, alters the rotation amount of the elements.


Hint
The angleMode() function is used to specify whether the rotate() function should be interpreted as DEGREES or RADIANS.

Checkpoint 3 Passed
3.
Underneath the angleMode() function , rotate the ellipses’ for loop by 30 degrees.


Hint
To rotate a function by 60 degrees (given DEGREES angle mode), your code will look like this:

rotate(60);

Checkpoint 4 Passed
4.
Right above the second for loop, rotate the rectangle pattern by frameCount * 10 radians.

Be sure to use the radians() function to convert the value into radians.


Hint
Remember, you can call the radians() function to convert a degree value into a radian value inside the rotate() function.

To convert 60 degrees into its radian value, you can write:

radians(60); // returns 1.0471975511965976

You may notice that since the angle mode was previously set to DEGREES, the converted radian value is actually used as a degree value! What the radians() function does here is to slow 
down the frameCount * 10 value for the rotation of the blue grid of rectangles.

sketch.js
---------
function setup() {
  createCanvas(windowWidth, windowHeight);
}

function draw() {
  background(0);
  fill(0);

  // TODO: Rotate the ellipse pattern by a quarter pi
  rotate(QUARTER_PI);

  // TODO: Specify the angle mode to be degrees
  angleMode(DEGREES);

  // TODO: Rotate by 30 degrees
  rotate(30);

  for (let i = 0; i < width *2 ; i += 75) {
    for (let j = 0; j < height *2 ; j += 75) {
      fill(255, 0, 0, 180);
      ellipse(i, j, 50, 50);
    }
  }

  // TODO: Rotate by frameCount * 10
  
  rotate(radians(frameCount *  10));
  for (let i = 0; i < width *2 ; i += 75) {
    for (let j = 0; j < height * 2; j += 75) {
      fill(0, 0, 255, 180);
      rect(i, j, 50, 50);
    }
  }
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Rotate Around a Shape's Center
--------------------------------
11 min
As we have seen in the previous exercise, the rotate() function on its own is not enough to rotate a shape around its center. When we rotate() an element, it often moves off the screen 
because the whole p5.js canvas is being rotated. In order to rotate a shape around its center, you first need to translate() the shape to be in the middle of the canvas.

// Move the origin to the center of the canvas
translate(width / 2, height / 2);

Then, you need to rotate your shape to the desired radian value. You can use the radians() function to convert the value passed to the rotate() function is in radians. In the example 
below, we use the p5.js frameCount variable to get the shape to rotate incrementally.

// Rotate by frameCount radians 
rotate(radians(frameCount));

Lastly, you need to draw the shape and set its origin point to be at the CENTER of the shape.

// Set the origin point to be the rectangle's center 
rectMode(CENTER);
rect (0, 0, 1, height); 

In order to rotate a shape around its top-left corner, you can set the mode to CORNER instead of CENTER. Since CORNER is the default origin point for drawing rectangles, you don’t need to 
explicitly call the rectMode() function. The two code examples below would produce the same result—a rectangle rotating around its top-left corner.

// Rotates from rectangle's top-left corner
rectMode(CORNER);
rotate(radians(frameCount));
rect (0, 0, 1, height); 

// Also rotates from rectangle's top-left corner because rectMode() is CORNER by default
rotate(radians(frameCount));
rect (0, 0, 1, height); 

The diagram below shows the difference between rotating a shape with a CORNER versus a CENTER origin point.

Rotating from the Corner Versus Center

Remember that the values for the transformation functions are accumulative. For example, the values passed into the first rotate() function will be added to any of the rotate() functions 
that are called afterward.

* Instructions 
--------------
Checkpoint 1 Passed
1.
Below the fill() function, specify the origin points of the rectangles to be the CENTER.


Hint
You can use the rectMode() function to set how the x and y positions of a rectangle’s origin point is interpreted—either CENTER or CORNER.

Checkpoint 2 Passed
2.
After the rectMode() function, translate the rectangles width / 2 to the right and height / 2 to the bottom. This will move your rectangles to the center of the canvas.


Hint
Use the translate() function to translate a shape. To translate a shape 100 pixels right and 150 pixels down, your code will look like this:

translate(100, 150);

Checkpoint 3 Passed
3.
Below the translate() function, rotate your rectangles by a quarter pi (π).


Hint
To rotate a shape, use the rotate() function. Remember that you have to spell out the radian amount in all caps, like HALF_PI.

To rotate a shape by HALF_PI, your code will look like this:

rotate(HALF_PI);

Checkpoint 4 Passed
4.
Rotate the second rectangle by frameCount / 2 in radians. Remember that you can convert a value to be in radians using the radians() function.

Now you should see the rectangle with a blue outline rotating from its center!


Hint
The radians() function converts a degree value to be in radians. This means that when the frameCount is at 180, the radian amount is 3.14 (π)—a half-circle rotation.

sketch.js
---------






function setup() {
  createCanvas(windowWidth, windowHeight);
}

function draw() {
  background(0, 15);
  stroke(0, 0, 255);
  fill(255, 0, 0, 50);
  
  // TODO: Specify the rectangle's origin point to be center
  rectMode(CENTER);

  // TODO: Translate rectangle to the center of canvas
  translate(width / 2, height / 2);

  // TODO: Rotate rectangle by a quarter pi
  rotate(QUARTER_PI);
  rect(0, 0, 450, 450); // First rectangle

  stroke(0, 0, 255);
  fill(255, 0);

  // TODO: Rotate rectangle by frameCount / 2 in radians
  rotate(radians(frameCount / 2));
  rect(0, 0, 450, 450); // Second rectangle
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Scale
-------
5 min
scale() is another function that transforms the p5.js coordinate system. As shown in the image below, you can see that the scale() function changes the size of the coordinate system as 
well the elements placed on it.

Example of how the scale function works

Notice how the size of the shape’s strokes also gets larger. This is because scale() enlarges the whole p5.js coordinate system, not just the shape. In a sense, the scale() function is 
like zooming in and out of the canvas.

The scale() function can take two arguments but must have at least one to represent the percentage amount for scaling the canvas. Scale values are written in decimal percentages. For 
example, scale(2.0) multiplies the size of the coordinate system and all of its elements by 200%. The default scale for the p5.js canvas is 1.0 or 100%.

scale(s, y);

Let’s take a closer look at the syntax above:

	. s represents the percentage value to scale the canvas. It is also the percentage to scale the canvas along the x-axis if the second y argument is given.

	. y can optionally be given to represent the percentage value to scale the canvas along the y-axis.

Similar to the rotate() function, if you want to scale a shape from its center, you would need to set the origin point of the shape to CENTER. In the image below, you can see the 
difference between scaling from a shape’s CORNER versus its CENTER.

Scale from Corner Versus Center

* Instructions
--------------
Checkpoint 1 Passed
1.
Above the first rect() function, scale the rectangle down by 0.5. This means the rectangle will scale down by 50%.


Hint
The syntax for scaling a shape is:

scale(value);

where value is a decimal number. To scale the canvas by 250%, your code will look like this:

scale(2.5);

Checkpoint 2 Passed
2.
Above the second rect() function, scale the rectangle up by a value of 4. This means it will scale up by 400%.


Hint
The syntax for scaling a shape is:

scale(value);

where value is a decimal number.

Checkpoint 3 Passed
3.
Below the last scale() function that scaled the rectangle by 400%, set the origin point of the rectangle to be CENTER.


Hint
You can use the rectMode() function to specify a rectangle’s origin point—either as CENTER or CORNER.

sketch.js
---------
function setup() {
  createCanvas(windowWidth, windowHeight);
}

function draw() {
  background(0);
  fill(255, 0, 0);

  // TODO: Scale the rectangle down by 0.5
  scale(0.5);
  rect(0, 0, 120, 120); // First rectangle

  fill(0, 0, 255);

  // TODO: Scale the rectangle up by 4
  scale(4);

  // TODO: Set the rectangle's origin point to be its center
  rectMode(CENTER);
  rect(100, 100, 120, 120); // Second rectangle
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Shear
-------
6 min
Shear functions skew a shape in a specific direction. The shape is sheared by the angle amount specified as the function’s argument. In p5.js, shapes are sheared in a clockwise direction. 
If the angle value is negative, the shape will shear in a counter-clockwise direction.

The image below shows a rectangle being sheared in both the x- and y-axis with angle values ranging from positive to negative.

Shearing a Shape Horizontally and Vertically

The shearX() function angles a shape around the x-axis by the amount given as its argument. The below code horizontally shears the rectangle by 0.5 radians.

shearX(0.5);
rect(100, 100, 150, 200);

The image below shows a rectangle sheared along the x-axis.

Shearing a Shape Horizontally

The shearY() function angles a shape around the y-axis by the amount specified as the argument. The below code vertically shears the rectangle by QUARTER_PI radians.

shearY(QUARTER_PI);

rect(100, 100, 150, 200);

The image below shows a rectangle sheared along the y-axis.

Shearing a Shape Vertically

Note that the arguments of the shearX() and shearY() functions are interpreted in radians by default but can be changed calling the angleMode() function before a shear function is called.

* Instructions
--------------
Checkpoint 1 Passed
1.
Below the rectMode() function, specify the angle mode to be in DEGREES.


Hint
You can specify the angle mode using the angleMode() function—either as DEGREES or RADIANS.

Checkpoint 2 Passed
2.
Above the first for loop, horizontally shear the red rectangles by 15 degrees.


Hint
The syntax to shear a shape along the x-axis is:

shearX(angle);

To horizontally shear a shape by 45 degrees, you would write:

shearX(45);

Checkpoint 3 Passed
3.
Above the second for loop, horizontally shear the blue rectangles by -15 degrees.


Hint
The syntax to shear a shape along the x-axis is:

shearX(angle);

Checkpoint 4 Passed
4.
Above the last for loop, vertically shear the purple rectangles by a value of frameCount / 25 degrees.


Hint
The syntax to shear a shape along the y-axis is:

shearY(angle);

sketch.js
---------
function setup() {
  createCanvas(windowWidth, windowHeight);
  noStroke();
}

function draw() {
  background(0);
  rectMode(CENTER);

  // TODO: Specify angle mode to be in degrees
  angleMode(DEGREES);

  // RED: First Pattern
  // TODO: Horiontally shear the pattern by 15 degrees
  shearX(15);
  for (let i = 0; i < width; i += 75) {
    for (let j = 0; j < height; j += 75) {
      fill(255, 0, 0, 180);
      rect(i, j, 50, 50);
    }
  }

  // BLUE: Second Pattern
  // TODO: Horiontally shear the pattern by -15 degrees
  shearX(-15);
  for (let i = 0; i < width; i += 75) {
    for (let j = 0; j < height; j += 75) {
      fill(0, 0, 255, 180);
      rect(i, j, 50, 50);
    }
  }

  // PURPLE: Third Pattern
  // TODO: Vertically shear the pattern by frameCount/25
  shearY(frameCount / 25);
  for (let i = 0; i < width * 2; i += 75) {
    for (let j = 0; j < height * 2; j += 75) {
      fill(200, 0, 255, 180);
      rect(i, j, 50, 50);
    }
  }
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Push and Pop
--------------
5 min
Isolating transformations is very helpful when you have multiple elements that you want to transform individually on a canvas. As we have learned, all transformation functions 
accumulate—this is where the push() and pop() functions come in handy. By surrounding code blocks with the push() and pop() functions, you can isolate transformations to be applied to 
targeted elements and not affect any elements that come after it.

The push() function saves the current style settings and transformations, while pop() restores it back to the original settings.

The example code below shows how the push() and pop() functions can be used to contain style and transformation functions for a particular shape:

push(); 
translate(30,50);
fill(255, 0, 0);
rect(0, 0, 100, 100);
pop();

Keep in mind that every push() needs a pop()! Also notice how the push() function always comes before the pop(). Sandwiched in-between push() and pop() are any style and transformation 
functions intended for one shape, but not for another.

Notice in pushpop.js on the right, we are able to isolate all three rectangles using push() and pop().

* Instructions
--------------
Checkpoint 1 Passed
1.
Open sketch.js.

Isolate the code block for the yellow spiral using the push() and pop() functions.

The code for the yellow spiral starts at the line:

translate(yellowX, yellowY);

and ends after the first for loop.

Notice how both yellow and blue spirals rotate at the center of the canvas!


Hint
You can isolate a block of code by writing the push() function at the beginning and the pop() function at the end.

Make sure to call the pop() function after the closing brackets for the first for loop.

Checkpoint 2 Passed
2.
Now, isolate the code block for the blue spiral. Even though encasing the code for the yellow spiral is enough to keep both spirals rotate at the center of the canvas, it is best practice 
to isolate code blocks that use transformation functions to prevent shapes added on later to the canvas from being affected.

The code for the blue spiral starts at the line:

translate(blueX, blueY);

and ends after the second for loop.


Hint
You can isolate a block of code by writing the push() function at the beginning and the pop() function at the end.

sketch.js
---------
let yellowX, yellowY;
let blueX, blueY;

function setup() {
  createCanvas(windowWidth, windowHeight);

  yellowX = width / 2;
  yellowY = height / 2;

  blueX = width / 2;
  blueY = height / 2;

  strokeWeight(5);
}

function draw() {
  background(255, 10);

  // TODO: Add push and pop to isolate the yellow spiral
  push();
  translate(yellowX, yellowY); // Start of code for yellow spiral
  rotate(frameCount * 0.001);
  stroke(255, 255, 0, 30);
  for (let i = 0; i < 24; i++) {
    rotate(PI / 12);
    line(0, 0, 0, 160);
  } // End of code for yellow spiral
  pop();
  
  // TODO: Add push and pop to isolate the blue spiral
  push();
  translate(blueX, blueY); // Start of code for blue spiral
  rotate(frameCount * 0.001 + PI / 8);
  stroke(0, 0, 255, 30);
  for (let i = 0; i < 24; i++) {
    rotate(PI / 12);
    line(0, 0, 0, 240);
  } // End of code for blue spiral
  pop();

}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Using Combinations of Transform Functions
-------------------------------------------
8 min
Interesting and complex sketches can be created when you combine the translate(), rotate(), and scale() functions.

When you apply multiple transformations, the order makes a big difference. A translate() followed by a rotate() then a scale() function will not create the same results if the order of 
operations were changed.

Look at the code below to see how each transformation functions are pieced together to create the animation of a rectangle, placed in the middle of the canvas, rotating from its center.

rectMode(CENTER);
translate(width/2, height/2); 
rotate(radians(frameCount)); 

fill(255,0,0);
rect(0, 0, 100, 100);

Rotating a Shape From its Center

Now, let’s change the order of operations. This time, we call the translate() function before the rotate() function. Everything else will remain the same, but notice how the resulting 
animation is wildly different.

rectMode(CENTER);
rotate(radians(frameCount)); 
translate(width/2, height/2); 

fill(255,0,0);
rect(0, 0, 100, 100);

Rotating a Shape

As you can see that the rectangle rotates from the upper left corner of the canvas in this new version. The rectangle is still translated to the center of the canvas, but only after the 
rotate() function has been applied. The rectangle leaves the canvas for a time because the rotation is happening at the default origin of the canvas at its top-left corner.

* Instructions
--------------
Checkpoint 1 Passed
1.
After the first push() function, translate the first rectangle with a red outline to be in the center of the canvas.

Calculate the x and y positions for the translate() function relative to the width and height variables.


Hint
You can use the translate() function to translate the canvas as follows:

translate(x, y);

where x is the number of pixels to be moved along the x-axis, and y is the number of pixels to be moved along the y-axis.

Checkpoint 2 Passed
2.
Below the translate() function, write a line to rotate the rectangle by frameCount in radians. Notice how the red rectangle is rotating at the center of the canvas.


Hint
The syntax to rotate a shape is:

rotate(angleValue);

In order to convert a degree or numeric value into radians you can use the radians() function.

Checkpoint 3 Passed
3.
Below the second push() function for the blue rectangle, rotate the rectangle by the frameCount in radians.


Hint
The syntax to rotate a shape is:

rotate(angleValue);

Make sure to use the radians() function to convert the frameCount value to radians.

Checkpoint 4 Passed
4.
Below the rotate() function you just added, translate the second rectangle to be in the center of the canvas.

Notice how this blue rectangle is rotating from the top-left corner and only appears on the canvas once in a while.


Hint
Make sure to calculate the x and y positions for the translate() function relative to the width and height variables.

sketch.js
---------
function setup() {
  createCanvas(windowWidth, windowHeight);
  frameRate(12);
}

function draw() {
  background(0, 25);
  rectMode(CENTER);

  // Red Rectangle: Translate then rotate
  push();

  // TODO: Translate to the center of canvas
  translate(width/2, height/2);

  // TODO: Rotate by frameCount
  rotate(radians(frameCount));
  
  noFill();
  stroke(255, 0, 0);
  rect(0, 0,windowWidth, windowHeight);
  pop();

  // Blue Rectangle: Rotate then translate
  push();
  
  // TODO: Rotate by frameCount
  rotate(radians(frameCount));

  // TODO: Translate to the center of canvas
  translate(width/2, height/2);

  noFill();
  stroke(0, 0, 255);
  rect(0, 0, windowWidth, windowHeight);
  pop();

}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

















































































































































































































































