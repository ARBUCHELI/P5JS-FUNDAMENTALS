# ANIMATION WITH P5.JS
----------------------

* Introduction
--------------
1 min
Now that you know how to draw a static sketch in p5.js, it is natural to wonder, “How can I make it move?”

In this lesson, you will learn how to make a p5.js drawing that changes with time, also known as an animation. An animation is really just an illusion. Any time we see an animation, we 
are actually seeing a sequence of frames that give us the illusion of movement. Frames are individual pictures in a sequence of images. When multiple frames are shown at a fast enough 
rate, our eyes translate and blend them into a single moving image. A classic example is Eadweard Muybridge’s Horse in Motion, in which the photographer took 12 photos of a galloping 
horse in rapid succession.

Eadweard Muybridge horse frames

When you show the pictures one after the other, it creates a motion-picture!

Eadweard Muybridge horse animated

In p5.js, this illusion of creating a moving image can be easily achieved by utilizing essential principles and functions such as the draw() loop, frames, and frame rates. In order to 
have control over your animation’s speed and states, it will be important to understand how to increment or decrement values, change variables, create your own functions, and use 
conditional statements.

By the end of this lesson, you will be able to make your p5.js drawings come to life!

* Instructions
--------------
Explore the p5.js sketch of this spaceship scene. Pay attention to the frameRate() function, the random() function, incrementing or decrementing values, creating custom functions, and 
writing conditional statements.

Click “Next” when you are ready to get started making p5.js animations!

sketch.js
---------
let x = 0; // Starting position for x
let y = 300; // Starting position for y
let size = 85; 
let speed = 5; 

function setup() {
  createCanvas(windowWidth, windowHeight);
  frameRate(32); // Slower frame rate
  noStroke();
}

function draw() {
  background(0);
  drawMoon(); 
  spaceship(x, y, size);

  if (x > width + 100) {
    x = -50; // Reset x position 
    y = random(0, height); // Reset at a random y position
  }
  x = x + speed; // Increment x position
}

// Custom function to draw the moon
function drawMoon() {
  // Moon
  fill(80);
  ellipse(width / 2, height / 2, width / 1.145);

  // Crater
  fill(0, 30);
  ellipse(width / 2 + width / 4, height / 2 - width / 4, width / 2);

  // Crater
  fill(0, 30);
  ellipse(width / 2 - width / 4, height / 2 + width / 10, width / 6);

  // Crater
  fill(0, 30);
  ellipse(width / 2, height / 2 + width / 3, width / 3);
}

// Custom function to draw spaceship
function spaceship(x, y, size) {
  fill(255);
  
  // Wings
  triangle(x + 25, y - size / 4, x + size, y + size / 4, x + 25, y + size * 3 / 4);
  
  // Body
  rect(x, y, size, size / 2, 5);
  ellipse(x + size, y + size / 4, size, size / 2);
  
  // Windows
  fill(0);
  ellipse(x + size / 3, y + size / 4, size / 4);
  ellipse(x + size * 2 / 3, y + size / 4, size / 4);
  ellipse(x + size, y + size / 4, size / 4);
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Frames
--------
9 min
In p5.js, multiple frames can easily be shown in a sequence using the draw() loop. By default, any code in the draw() function will repeat over and over again, many times per second. This 
function’s endless repetition is ideal for making an animation because we can write code in the draw() function that slightly alters our image each time it runs.

As a quick recap, the draw() function is similar to an endless for-loop that repeatedly runs the code block inside from top to bottom. The draw() function runs after the setup() function 
that runs only once at the program’s start.

function setup(){
  // Code inside setup() function runs once when you start the program
}
function draw(){
  // Code inside draw() function loops infinitely after setup() is run
}

It is helpful to think of an animation as a series of frames, like a film roll. By showing the series of frames fast enough, our brain is tricked into thinking the sequential images are 
an animation. The example below shows a series of frames shown like a film roll.

Series of Frames

To create a smooth animation with code, p5.js runs the draw loop at 60 frames per second. Below is an example of how each frame is overriding the previous one to create this animation.

Series of Frames

With p5.js, one frame is the equivalent to one loop through the draw() function. To keep track of the number of frames rendered, p5.js provides a built-in variable called frameCount. This 
variable counts the number of frames that have been displayed since the program started. The frameCount variable updates with every frame. The first time the draw() loop runs, the value 
of the frameCount is one; the second time the draw() loop runs, the frameCount is two; and so forth.

* Instructions
--------------
Checkpoint 1 Passed
1.
Below the line of code that sets fill color to white, draw an ellipse using the frameCount variable as the x position. Let the y position be height / 2. Set the width and height to be 300 
pixels. See how the ellipse moves from the left to right because the frameCount value increases with every frame.


Hint
Remember that the syntax for drawing an ellipse is as follows:

ellipse(x, y, ellipseWidth, ellipseHeight);

Make sure to draw the ellipse below the line that sets the fill color to white like below:

fill(255);

Checkpoint 2 Passed
2.
In the last line within the draw() function, draw text using the text() function. Set the first parameter to be the frameCount variable. Set the second parameter, which is the x location, 
to be width / 2. Set the third parameter, which is the y location, to be height / 2.

Notice how p5.js keeps track of the number of frames run since the program begins.


Hint
You can draw text to the p5.js canvas using the text() function with the following syntax:

text(word, x, y);

where word represents the text to be drawn and x and y respectively refer to the x and y position of the text.

sketch.js
---------
function setup() {
  createCanvas(windowWidth,windowHeight);
}

function draw() {
  background(0);

  //Draw moving ellipse
  fill(255);
  // TODO: draw an ellipse with frameCount as the x position
  ellipse(frameCount, height/2, 300, 300);

  //Draw text 
  fill(120); 
  textSize(72);
  textAlign(CENTER);

  // TODO: create text with frameCount displayed in sketch
  text(frameCount, width/2, height/2);
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* FPS
-----
3 min
Frames Per Second (FPS) specifies the number of frames displayed every second. When the FPS of animation is lower, it looks like it is in slow motion. When the frame rate is higher, the 
animation looks like it is being fast-forwarded.

p5.js will automatically run your code at 60 frames per second. However, you can manipulate the FPS by using the frameRate() function, which will change the number of frames shown per 
second to the number specified as the function’s argument. For example, the code snippet below will cause the draw() function to run numberOfFrames times per second.

frameRate(numberOfFrames);

The frameRate() function will not go over 60 frames per second in p5.js. This is more than enough! A typical animation is between 24 to 30 frames per second.

Different FPS

In the diagram above, you can see the ball dropping at ten frames per second (10 FPS), 30 frames per second (30 FPS), and 60 frames per second (60 FPS). Notice that when the animation has 
a lower frame rate, each frame is more distinct.

* Instructions
--------------
Checkpoint 1 Passed
1.
Let’s play around with the frame rate to manipulate the speed the sketch is run at. Below the createCanvas() function, add a frame rate of 60 frames per second in the setup() function.


Hint
Use the frameRate() function in the setup() function to set the FPS of the sketch to 60.

Checkpoint 2 Passed
2.
Below the line you just added, set the frame rate to 24 frames per second.

Remember that code runs from top to bottom, so this new frame rate will override the frame rate we set in the above instruction. Notice the change in animation speed.


Hint
Below the line you set the frame rate to 60 FPS, use the frameRate() function to set frame rate to 24.

Checkpoint 3 Passed
3.
Below the line you just added, write a new frameRate() function and set it to run at 6 frames per second.

Notice how the animation has slowed down and now has a stop motion effect.


Hint
Below the line you set the frame rate to 24 FPS, use the frameRate() function to set the frame rate to 6.

sketch.js
---------
let yPos = 0;
let ySpeed = 5;

function setup() { 
  createCanvas(windowWidth, windowHeight);
  // TODO: Set the frame rate to be 60 FPS
  frameRate(60);
  // TODO: Set the frame rate to be 24 FPS
  frameRate(24);
  // TODO: Set the fram erate to be 6 FPS
  frameRate(6);
} 

function draw() { 
  background(0);
  fill(255);
  // Draws the ellipse
  ellipse(width/2, yPos, 100,100);
  
  // Moves the ellipse down the canvas
  yPos = yPos + ySpeed; 
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Incrementing and Decrementing Values
--------------------------------------
8 min
Variables are a crucial component for creating movement in p5.js. To have your sketch change over time, you will need to increment or decrement your variables with each frame.

Remember that after you declare a variable, you can always reassign it by giving it a new value. In order to have your element move across the canvas, it is necessary to first define your 
variable, then reassign that variable to be incrementing and decrementing.

The code below shows how to increment an ellipse along the x-axis of the canvas.

// Initialize xPos variable to 5
let xPos = 5;

function draw(){
  // Use xPos variable as x position of ellipse
  ellipse(xPos, 100, 100, 100);
  // Increment xPos by 1 every draw loop
  xPos += 1; 
}

A value is incremented by writing the following expression:

x = x + 1;

Above, the x variable is taking its own value and then adding 1 to it. This expression can also be written as x++ or x += 1.

A value is decremented by writing the following expression:

x = x - 1;

Here, the x variable is taking its own value and then subtracting 1 from it. This expression can also be written as x-- or x -= 1. Keep in mind that the value 1 can be changed to any 
other number.

* Instructions
--------------
Checkpoint 1 Passed
1.
In this exercise, you will reassign variables in order to gradually change the size, color and position of the ellipse over time.

In the draw() loop underneath the fill() function, create an ellipse with the global variable xPos for the x position, height / 2 for the y position, and size for the width and the 
height.


Hint
Remember that you can create an ellipse with the following syntax:

ellipse(x, y, ellipseWidth, ellipseHeight);

Checkpoint 2 Passed
2.
In the line below the ellipse() function call, increment the color variable by 1.


Hint
You can increment a value by writing:

x += 1;

This takes the current value of the variable and then adds 1 to it.

You can also write the above expression as:

x = x + 1;

Checkpoint 3 Passed
3.
Now that we have incremented the ellipse’s color, let’s increment the size of the ellipse. Increment the size variable by 0.5.


Hint
You can increment a value by writing:

x += 1;

This takes the current value of the variable and then adds 1 to it.

You can also write the above expression as:

x = x + 1;

Checkpoint 4 Passed
4.
Let’s do the same for the x position of the ellipse. Reassign the xPos variable so it is decrementing by a value of 2.

Great job! The previously static sketch we started out with is now an animation with many elements changing over time.


Hint
You can decrement a value by writing:

x -= 1;

This takes the current value of the variable and then subtracts 1 from it.

You can also write the above expression as:

x = x - 1;

sketch.js
---------
let xPos = 0;
let color = 1;
let size = 1;

function setup() { 
  createCanvas(windowWidth, windowHeight);
  xPos = width;
} 

function draw() { 
  background(0);
  fill(color);

  // TODO: Draw an ellipse with xPos variable for the x position
  ellipse(xPos, height/2, size, size);
  // TODO: increment the color variable by 1
  color += 1;
  // TODO: increment the size variable by 0.5
  size += 0.5;
  // TODO: decrement the xPos variable by 2
  xPos -= 2;
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Speed and Direction
---------------------
14 min
In order to create smooth animations, we need to create a variable for the speed and then incrementally change that value with each frame.

In the example below, we are animating an ellipse that is falling at a set speed. To achieve this, we first define a variable named speed. We then set a variable named yPos for the 
ellipse’s y position. Afterward, we increment yPos with the speed variable.

let speed = 1; // Determines the speed
let yPos = 0; // Starting position on y-axis

function draw(){
   ellipse(width / 2, yPos, 20, 20); 
   yPos += speed; // Increments the value of the y position
}

To reset the ellipse to its initial location, we first write an if statement to check whether the ball has reached the bottom of the canvas. You can tell if it has reached the bottom when 
the y position of the ball is greater than the height (yPos > height). At this point, reassign the y position of the ball back to 0, which is the top of the canvas.

if(yPos > height) {
  yPos = 0; // When yPos becomes greater than height, reset to 0
}

With the code above you can create this infinitely looping animation of a dropping ball.

Reset Ball

Instead of resetting the ball’s position to the top, you can have it bounce up when it reaches the bottom of the sketch. To move the ball in the opposite direction, inverse the speed 
variable by multiplying the value by -1.

if(yPos > height){
  speed = speed * -1; // Negative value changes speed to opposite direction
}

By inverting the direction of the speed, we have created an animation of a ball that bounces when it reaches the bottom.

Bouncing Ball

Let’s now try to have the ball bounce off all four sides of the canvas!

To achieve this, we first need to differentiate the speed for the x-axis and the y-axis movement. Let’s do this by creating variables called xSpeed and ySpeed to represent the movements 
along both axes.

// Initialize speed along x and y-axis to 1
let xSpeed = 1; 
let ySpeed = 1; 

Next, let’s write an if statement to check when the ellipse’s x position is greater than the canvas width or less than 0. We use an OR operator (||) to check if either condition is true.

if(xPos < 0 || xPos > width) {
  // If xPos is less than 0 or greater than width, run this code
}

We need to write another if statement to check when the ellipse’s y position is greater than the canvas height or less than 0.

if(yPos < 0 || yPos > height) {
  // If yPos is less than 0 or greater than height, run this code
}

When the ellipse touches any side of the canvas, we move it in the opposite direction by multiplying -1 to the variable representing speed. We write the code to change the direction 
within the if statements.

if(xPos < 0 || xPos > width) {
  xSpeed = xSpeed * -1; // Invert xSpeed when xPos is less than 0 or greater than width
}

if(yPos < 0 || yPos > height) {
  ySpeed = ySpeed * -1; // Invert ySpeed when yPos is less than 0 or greater than height
}

When we piece all the steps together it will create an animation of a ball bouncing around the canvas.

Bouncing Ball

* Instructions
--------------
Checkpoint 1 Passed
1.
Let’s practice controlling the speed and direction by creating a bouncing ball around the canvas. Note that the global variables are already defined for you at the top of the sketch.

Underneath the ellipse() function, increment the circleX variable, the x position of the ball, by a value of xSpeed. This will move your ball along the x-axis.


Hint
Remember that you can increment a value by writing:

x += amount;

This takes the current value of the variable and then adds amount to it.

Checkpoint 2 Passed
2.
Below the line you just added, increment the circleY variable, the y position of the ball, by a value of ySpeed. Your ball should now be gradually dropping diagonally.


Hint
Remember that you can increment a value by writing:

x += amount;

This takes the current value of the variable and then adds amount to it.

Checkpoint 3 Passed
3.
Now, let’s make the ball move in the opposite direction anytime it reaches the left and right sides of the canvas.

Below the increment statements you added, write an if statement that evaluates whether the circleX variable has become less than 0 or greater than the canvas width. If the ball has 
reached either end, invert the direction of the xSpeed.


Hint
Remember that you can use the OR operator (||) inside the if statement to check if one of the multiple statements is true.

You can invert the direction by multiplying the speed value by -1.

Checkpoint 4 Passed
4.
Lastly, write another if statement that evaluates whether the circleY variable has has become less than 0 or greater than the canvas height. If the ball has reached either side, invert 
the direction of the ySpeed.

Your ball should now bounce anytime it has reached any sides of the canvas.


Hint
Remember that you can use the OR operator (||) inside the if statement to check if one of the multiple statements is true.

You can invert the direction by multiplying the speed value by -1.

sketch.js
---------
// Global variables
let circleX = 300;
let circleY = 0;
let xSpeed = 1;
let ySpeed = 1;

function setup() {
  createCanvas(windowWidth, windowHeight);
}

function draw() {
  background(0);
  // Bouncing ball
  ellipse(circleX, circleY, 120);
  
  // TODO: Increment the x position of the ball
  circleX += xSpeed;

  // TODO: Increment the y position of the ball
  circleY += ySpeed;

  // TODO: If statment to inverse direction when ball hits left or right edge
  if (circleX < 0 || circleX > width) {
    xSpeed *= -1;
  }

  // TODO: If statment to inverse direction when ball hits top or bottom edge
  if (circleY < 0 || circleY > height) {
    ySpeed *= -1;
  }
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Random
--------
11 min
If you want to add some unpredictability to your sketch, random() is the perfect function for you! This is especially helpful when you are tired of making decisions and are happy to let 
computation make some of them for you.

The random() function returns a random value every time it is called. There are a few ways to write this function:

	. random() returns a value between 0 and 1.

	. random(max) returns a value between 0 and max value, but excluding the max value.

	. random(min, max) returns a value between min value and max value, but excluding the max value.

	. If the random() function is used inside the draw() loop, the random() function generates a different randomized value every time the draw() function runs.

The image below shows multiple circles appearing in random locations and sizes every time it runs through the draw() function.

Random Position and Size

The above animation is created using the code snippet below:

let xPos = random(width); // Generate random number between 0 and width
let yPos = random(height); // Generate random number between 0 and height
let size = random(10, 101); // Generate random number between 10 and 100

circle(xpos, ypos, size);

Here, the xPos variable is set to a random value between 0 and canvas width and the yPos variable to a random value between 0 and canvas height. The size variable is set to a random 
number between 10 and 100. These randomly generated values are used to generate circles at random positions and sizes.

Similar to how we used the random() function to generate random sizes and positions for our ellipses, we can also use the random() function to get a random color value.

Remember that you can use the RGB notation as the color arguments for the fill() function. Refer to the Drawing and Coloring Shapes lesson if you would like to review how to use colors in 
p5.js.

The code below generates random values between 0 and 255 for the red, green, and blue values. Keep in mind that in order to get a value between 0 and 255, including 255, you need to pass 
256 into the random() function since the maximum value is exclusive.

fill(random(256), random(256), random(256)); 

This can also be written as:

fill(random(0, 256), random(0, 256), random(0, 256));

All Random Colors

Passing in random values for all three color channels will give you this fun, rainbow color scheme. Rainbows are awesome! But sometimes you may want to have a limited, but still random, 
color palette. For example, if you want all the ellipses to be within the red spectrum, you can choose to randomize only the red value.

fill(random(256), 0, 0); 

Now, all the ellipses are varying shades of red.

Red Random Colors

* Instructions
--------------
Checkpoint 1 Passed
1.
Let’s practice using the random() function to animate the position and color of your ellipses.

Inside the draw() function, set the circleX variable to be a random value between 0 and width.


Hint
Remember that you can generate a random value by writing:

let randomNumber = random(min, max);

where min represents the value of the minimum range and max represents the value of the maximum range. Remember that the randomly generated number does not include the max value.

Checkpoint 2 Passed
2.
Next, set the circleY variable to be a random value between 0 and height.


Hint
Remember that you can generate a random value by writing:

let randomNumber = random(min, max);

where min represents the value of the minimum range and max represents the value of the maximum range. Remember that the randomly generated number does not include the max value.

Checkpoint 3 Passed
3.
Now, write a fill() function and set the value to be a random number between 0 and 256.

Since there is only one value passed into the fill() function, the color will be a value between black (0) and white (255).


Hint
Remember that you can set a gray fill color by passing one numeric argument to the fill() function like below:

fill(grayValue);

Remember that the randomly generated number does not include the grayValue value.

Checkpoint 4 Passed
4.
At the bottom of your draw() function, create an ellipse. Pass in the circleX variable for the x position, circleY for the y position, and 50 for the width and height.


Hint
Remember that you can draw an ellipse with the following syntax:

ellipse(x, y, ellipseWidth, ellipseHeight);

sketch.js
---------
let circleX;
let circleY;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
  noStroke();
  frameRate(10);
}

function draw(){
  // TODO: Set the elliipse's x position to be a random position
  circleX = random(0, width);

  // TODO: Set the elliipse's y position to be a random position
  circleY = random(0, height);

  // TODO: Set the fill to be a random value between white and black
  fill(random(0, 256));

  // TODO: Create an ellipse with defined variables passed in
  ellipse(circleX, circleY, 50, 50);
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Noise
-------
12 min
As you may have noticed in the previous exercise, sometimes the random() function can be too random. There may be times when you want to create random movements that are more natural. 
Thankfully, p5.js has a noise() function that does exactly this!

The noise() function returns a random value based on the Perlin noise. When you call the noise() function, it generates a naturally ordered sequence of random numbers. The diagram below 
shows Perlin noise over time, which is represented as the x-axis. Notice how smooth the curve is for the noise() graph. In contrast, notice how jumpy the curve is for the random() graph. 
This is because the random() function selects purely random numbers with no relation to the previously selected value. Whereas, the noise() function generates values that produce a more 
harmonic sequence of numbers.

Random vs Noise Graph

You can generate a noise value with the following syntax:

let num = noise(x, y);

Let’s take a closer look:

	. The x value specifies the x-coordinate in noise space.

	. The y value specifies the y-coordinate in noise space.

	. The number returned when you call the noise() function is between 0 and 1.

	. The noise() function can’t be called without at least one argument.

The difference between the random() and noise() function is especially noticeable when used in animations. You can see in the example below how sporadic the motion is when the random() 
function is used for the ellipse’s x position.

Random Movement

The animation below uses the noise() function for the x position of the ellipse. Compare the movement with the above ellipse.

Noise Movement

In order to create this wandering ellipse animation, we need to first set a variable for the value we wish to increment along the x-axis. We do this by writing:

let xOffset = 0;

Next, we set the x variable to be equal to:

map(noise(xOffset), 0, 1, 0, width);

This function maps the value generated from the noise() function, which will be between 0 and 1, to a number between 0 and width. You can read more about how to use the map() function in 
the Tips for Creating Animations with p5.js article.

We then pass the x variable into the x position of the ellipse:

ellipse(x, 200, 24, 24);

The last step is to increment our xOffset value by writing:

xOffset += 0.01;

When we put all the steps together, you get the below code that creates these nice, semi-random movements.

let xOffset = 0;
let x = map(noise(xOffset), 0, 1, 0, width);
  
fill(255);
ellipse(x, 200, 24, 24);
xOffset += 0.01;

* Instructions
--------------
Checkpoint 1 Passed
1.
In this exercise, you will use the noise function to make a wandering ball animation. First, inside the draw() function, set the x variable to equal:

width * noise(t + 15)

Be sure to write this somewhere after the fill() function.


Hint
Remember, that the number returned when you call a noise() function is between 0 and 1. This is why we need to multiply the value generated by noise() with the width value.

Checkpoint 2 Passed
2.
Still inside the draw() function, set the y variable to equal:

height * noise(t + 5)

We will be using this variable for the ellipse’s y position.


Hint
The number returned when you call a noise() function is between 0 and 1. This is why we need to multiply the value generated by noise() with the height value.

Checkpoint 3 Passed
3.
Now, draw an ellipse with the x variable for the x position and the y variable for the y position. Set the width and height of the ellipse to be 150.


Hint
Remember that you can draw an ellipse with the following syntax:

ellipse(x, y, ellipseWidth, ellipseHeight);

Checkpoint 4 Passed
4.
As the last step, increment the t value by 0.005. Your ellipse should now be gracefully gliding around the canvas!


Hint
Remember that you can increment a value by writing:

x += amount;

This takes the current value of the variable and then adds amount to it.

sketch.js
---------
// Global variables
let t; 
let x; // X position
let y; // Y position

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
  t = 0;
}

function draw() {
  background(0, 16);

  noStroke();
  fill(255);

  // TODO: Set the x position to incorporate the noise function
  x = width * noise(t + 15);

  // TODO: Set the y position to incorporate the noise function
  y = height * noise(t + 5);

  // TODO: Draw an ellipse with the variables for x and y passed in
  ellipse(x, y, 150, 150);

  // TODO: Increment the t variable to control the noise amount
  t+= 0.005;
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Creating Custom Functions
---------------------------
8 min
p5.js is built on functions. For example, the draw() loop is a function used in every sketch. All shapes are drawn using functions such as ellipse(), rect() and line().

As a reminder, you can define functions by writing:

function nameOfFunction (x, y, z){
   // Do something when this function is called
}

In the code above, x, y, and z are variables that represent the function’s parameters. Parameters are a way to introduce variations into your functions. For example, let’s say you want to 
draw three clouds, but you want each cloud’s location and size to be different. To do this, you would need to write parameters for your makeCloud() function. When you call the function, 
the variables get replaced with the specific values passed into that makeCloud() function call.

Take a look at the cloud.js file to your right. See how the function’s parameters are used to create variations. Keep in mind that p5.js runs through the program line by line, from top to 
bottom. Every time the program reaches a makeCloud() function call, the program jumps to the function definition outside of the draw() loop.

* Instructions
--------------
Checkpoint 1 Passed
1.
With this exercise, you will practice calling a function and passing parameters into it.

Open sketch.js. Inside the draw() function and below the background() function, call the function makeCircle(), which is already defined in the sketch. Pass in the value 4 for the xPos, 
50 for the yPos, and 600 for the circleSize parameter.


Hint
Make sure that the order in which you pass in the values for the function’s parameters correlates to how the function is defined.

Checkpoint 2 Passed
2.
Below the one you just called, write a new call to the makeCircle() function. Pass in the value 0 for the xPos, 200 for the yPos, and 200 for the circleSize parameter.


Hint
Make sure that the order in which you pass in the values for the function’s parameters correlates to how the function is defined.

Checkpoint 3 Passed
3.
Below your second makeCircle() function, write your last call to the makeCircle() function. Pass in the value 100 for the xPos, 200 for the yPos, and 1 for the circleSize parameter.


Hint
Make sure that the order in which you pass in the values for the function’s parameters correlates to how the function is defined.

cloud.js
--------
let xPos = 0;
let yPos;
let cloudSize;

function setup() {
  createCanvas(400, 400);
}

function draw() {
  background(0);

  makeCloud(xPos + width / 2, 50, 50);
  makeCloud(xPos + width / 7, 210, 140);
  makeCloud(xPos + width / 1.5, 340, 70);
}

function makeCloud(xPos, yPos, cloudSize) {
  noStroke();
  fill(255);

  ellipse(xPos, yPos, cloudSize);
  ellipse(xPos + cloudSize / 2, yPos, cloudSize);
  ellipse(xPos + cloudSize, yPos, cloudSize);
  ellipse (xPos + cloudSize/2, yPos - cloudSize/3, cloudSize);
}

sketch.js
---------
let t;
let increment = 0.001; 

function setup() {
  createCanvas(windowWidth, windowHeight);
  strokeWeight(2);
  stroke(255);
  noFill();
  t = 0;
}

function draw() {
  background(0, 15);

  // TODO: Call the makeCircle() function with 4 for xPos, 50 for yPos and 600 for circleSize
  makeCircle(4, 50, 600);

  // TODO: Call the makeCircle() function with 0 for xPos, 200 for yPos and 200 for circleSize
  makeCircle(0, 200, 200);

  // TODO: Call the makeCircle() function with 100 for xPos, 200 for yPos and 1 for circleSize
  makeCircle(100, 200, 1);
}

function makeCircle(xPos, yPos, circleSize) { 
  let x = width * noise(t + xPos);
  let y = height * noise(t + yPos);
  let size = width * noise(t + circleSize);

  ellipse(x, y, size, size);

  t += increment;
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Review
--------
3 min
Wonderful! You now know how to create animations in p5.js! Let’s review what we’ve covered in this lesson:

A frame is the equivalent to a loop through the draw() function.
A p5.js sketch runs at 60 frames per second, meaning that the draw() function executes 60 times per second.
You can use the frameRate() function to alter how many frames are displayed in a second, also know as Frames Per Second (FPS).
Increment and decrement values to create continuous motion.
Conditional statements can be used to create more complicated animation sequences.
Create variables to increment or decrement the speed of a moving object.
Invert the direction of the moving object by using conditionals and multiplying -1 to existing speed values.
The random() function is used for creating unpredictable and dynamic movements.
The noise() function is used for creating unpredictable but smoother movements.
Create your own functions so your code is modular and reusable.

In the next lesson, we will be covering how to create different transformations that can be applied to our shapes. We will also be going over how to group our styles, transformations, and 
functions in order to create animations that are even more complex and dynamic!

* Instructions
--------------
Inside the shooting star animation in sketch.js file on your right, play around with the frameRate() value. Pay attention to the specific animation principles we just learned. Change the 
values inside the random() function. How do these tweaks alter the animation?

sketch.js
---------
let sparkleX;
let sparkleY;
let sparkleSize;

let starX = 0;
let starY = 0;
let starSize = 6;
let starSpeed = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  // Set frame rate to 36 FPS
  frameRate(36);
}

function draw() {
  background(0, 50);

  // Set random values every draw loop
  sparkleX = random(0, width);
  sparkleY = random(0, height);
  sparkleSize = random(0, 10);

  fill(255);
  noStroke();
  ellipse(sparkleX, sparkleY, sparkleSize);

  // Create a shooting start animation defined in shootingStar() function
  shootingStar(4);
}

function shootingStar(starSpeed) {
  fill(255);
  noStroke();
  ellipse(starX, starY, starSize);
  starX = starX + starSpeed;
  starY = starY + starSpeed;
  starSize = starSize + 0.1;
  
  if(starX > width || starY > height){
    starX = 0;
    starY = 0;
    starSize = 1;
  }
}



























































































































































































